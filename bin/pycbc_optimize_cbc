#!/bin/env python
"""Followup a candidate"""
import h5py, numpy, argparse, logging
import pycbc.version, pycbc.strain, pycbc.waveform, pycbc.pnutils, pycbc.filter
import pycbc.conversions, pycbc.types, pycbc.dq, pycbc.scheme
from scipy.optimize import differential_evolution
from pycbc.types.optparse import DictWithDefaultReturn

def params_from_waveformstr(wstr):
    wparams = {}
    for param in wstr:
        key, value = param.split(':')
        try:
            rvalue = float(value)
        except ValueError:
            rvalue = value
        wparams[key] = rvalue
    return wparams

def network_snr(wparam, trig_time, stilde, psd, fixed):
    mchirp, q, spin = wparam
    p = fixed.copy()
    p['mass1'] = pycbc.conversions.mass1_from_mchirp_q(mchirp, q)
    p['mass2'] = pycbc.conversions.mass2_from_mchirp_q(mchirp, q)
    p['spin1z'] = p['spin2z'] = spin
    with ctx:
        out = pycbc.types.zeros(len(psd.values()[0]), dtype=numpy.complex64)
        hp = pycbc.waveform.get_waveform_filter(out,
                            delta_f=stilde.values()[0].delta_f, **p)
        nsnr = 0
        for ifo in strain:
            snr = pycbc.filter.matched_filter(
                        hp, stilde[ifo], psd=psd[ifo],
                        low_frequency_cutoff=p['f_lower'])
            z = snr.time_slice(trig_time - 0.1, trig_time + 0.1)
            nsnr += abs(z).max() ** 2.0
    return -nsnr ** 0.5

parser = argparse.ArgumentParser()
parser.add_argument('--version', action='version',
    version=pycbc.version.git_verbose_msg)
parser.add_argument('--verbose', action='store_true')
parser.add_argument('--output-file')

# Options related to getting trigger information from workflow products
parser.add_argument('--input-file',
    help="HDF File which gives the trigger followup information for a set")
parser.add_argument('--start-index', type=int)
parser.add_argument('--end-index', type=int)
parser.add_argument('--stride', type=int, default=1)

# Options to directly supply followup information
parser.add_argument('--template-parameters', nargs='+')
parser.add_argument('--trigger-time', type=float)
parser.add_argument('--instruments', nargs='+',
    help="Maximum set of instruments which may be used")

parser.add_argument('--adjust-psd-center', action='store_true',
    help="If using an hdf_store check the internal segments and "
         "match the time to the available data")

# Options related to data / signal processing options
parser.add_argument('--low-frequency-cutoff', type=float)
pycbc.strain.insert_strain_option_group_multi_ifo(parser, gps_times=False)
pycbc.scheme.insert_processing_option_group(parser)

args = parser.parse_args()
pycbc.init_logging(args.verbose)
ctx = pycbc.scheme.from_cli(args)
ofile = h5py.File(args.output_file, 'w')

if args.input_file:
    f = h5py.File(args.input_file, 'r')
    start = 0 if args.start_index is None else args.start_index
    end = len(f['time']) if args.end_index is None else args.end_index
    stride = args.stride
    ofile.attrs['start_index'] = start
    ofile.attrs['end_index' ] = end
    wparams = f['waveparams'][start:end:stride]
    triggers = (f['time'][start:end:stride], f['offsets'][start:end:stride],
                [dict(zip(wparams.dtype.names, x)) for x in wparams])

elif args.trigger_time:
    waveparams = params_from_waveformstr(args.template_parameters)
    toffset = {ifo:0 for ifo in args.instruments}
    triggers = ([args.trigger_time], [toffset], [waveparams])

if args.adjust_psd_center:
    segs = {}
    for ifo in args.instruments:
        f = h5py.File(args.hdf_store[ifo], 'r')
        segs[ifo] = (f[args.channel_name[ifo]]['segments/start'][:],
                     f[args.channel_name[ifo]]['segments/end'][:])


stats = []
for i, (trigger_time, time_offsets, waveparams) in enumerate(zip(*triggers)):
    logging.info('Starting work on trigger %s/%s: %s', i, len(triggers[0]), trigger_time)
    psdlen = 128
    psdseg = 8

    m1, m2 = waveparams['mass1'], waveparams['mass2']
    mchirp = pycbc.conversions.mchirp_from_mass1_mass2(m1, m2)
    waveparams['approximant'] = 'SPAtmplt' if mchirp < 3 else 'IMRPhenomD'
    templatelen = pycbc.waveform.get_waveform_filter_length_in_time(**waveparams)
    filterbuffer = templatelen + 4.0 + psdseg * 2
    filterbuffer = pycbc.pnutils.nearest_larger_binary_number(filterbuffer)
    logging.info('Template duration is %s seconds', templatelen)
    logging.info('We need %s seconds to filter this waveform', filterbuffer)

    args.gps_start_time = DictWithDefaultReturn()
    args.gps_end_time = DictWithDefaultReturn()
    psd_start, psd_end = {}, {}
    filter_start, filter_end = {}, {}

    # Allow an IFO to be excluded using a sentinel value
    ifos = [ifo for ifo in args.instruments if time_offsets[ifo] != numpy.inf]

    # Determine what data we need to read and prepare
    for ifo in ifos:
        filter_end[ifo] = int(trigger_time + psdseg + 2)
        filter_start[ifo] = filter_end[ifo] - filterbuffer
        logging.info('%s: Filter buffer goes from %s-%s',
                     ifo, filter_start[ifo], filter_end[ifo])

        pad = 0 if args.pad_data[ifo] is None else args.pad_data[ifo]

        psd_start[ifo] = int(trigger_time - psdlen // 2)
        if args.adjust_psd_center:
            idx = numpy.searchsorted(segs[ifo][0],
                                     trigger_time + time_offsets[ifo]) - 1
            start = segs[ifo][0][idx] - time_offsets[ifo]
            end = segs[ifo][1][idx] - time_offsets[ifo]
            if start > psd_start[ifo] - pad:
                psd_start[ifo] = start
            if end < psd_start[ifo] + pad + psdlen:
                psd_start[ifo] = end - pad - psdlen
        psd_end[ifo] = psd_start[ifo] + psdlen
        logging.info('%s: PSD data will be %s-%s', ifo, psd_start[ifo], psd_end[ifo])

        data_start = min(psd_start[ifo], filter_start[ifo]) - pad
        data_end = max(psd_end[ifo], filter_end[ifo]) + pad
        logging.info('%s: Will need data from %s-%s', ifo, data_start, data_end)

        args.gps_start_time[ifo] = data_start + pad + time_offsets[ifo]
        args.gps_end_time[ifo] = data_end - pad + time_offsets[ifo]
        logging.info('%s: actually reading %s-%s',
                     ifo, data_start + time_offsets[ifo],
                     data_end + time_offsets[ifo])

    logging.info('Calculating Strain around trigger')
    strain = pycbc.strain.from_cli_multi_ifos(args, ifos,
                                              dyn_range_fac=pycbc.DYN_RANGE_FAC)

    # Undo any time offsets for slides
    stilde = {}
    psd = {}
    for ifo in strain:
        strain[ifo].start_time = round(strain[ifo].start_time - time_offsets[ifo])

        spart = strain[ifo].time_slice(filter_start[ifo], filter_end[ifo])
        stilde[ifo] = spart.to_frequencyseries()

        logging.info('Calculating PSD around time')
        spart = strain[ifo].time_slice(psd_start[ifo], psd_end[ifo])
        psd[ifo] = spart.filter_psd(psdseg, stilde[ifo].delta_f,
                                    args.low_frequency_cutoff)

    logging.info('Optimizing Parameters')
    minchirp = mchirp * (1 - mchirp / 200.0) # need better way to set limits
    maxchirp = mchirp * (1 + mchirp / 200.0)
    minchirp = 1 if minchirp < 1 else minchirp
    maxchirp = 80 if maxchirp > 80 else maxchirp

    q = max(m1 / m2, m2 / m1)
    minq, maxq = q * 0.7, q * 1.5
    minq = 1.0 if minq < 1 else minq
    maxq = 100 if maxq > 100 else maxq
    logging.info('Using chirp mass range %s-%s', minchirp, maxchirp)
    logging.info('Using mass ratio range %s-%s', minq, maxq)
    bounds = [(minchirp, maxchirp), (minq, maxq), (-.98, 0.98)]
    result = differential_evolution(network_snr, bounds, popsize=20,
                                    args=(trigger_time, stilde,
                                          psd, waveparams),
                                    disp=args.verbose, seed=0)
    logging.info(result)
    stat = result['fun'] * -1.0
    stats.append(stat)

ofile['stat'] = numpy.array(stats)
logging.info('Done')
