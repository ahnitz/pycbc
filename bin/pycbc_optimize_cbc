#!/bin/env python
"""Followup a candidate"""
import h5py, numpy, argparse, logging
import pycbc.version, pycbc.strain, pycbc.waveform, pycbc.pnutils, pycbc.filter
import pycbc.conversions, pycbc.types
from scipy.optimize import differential_evolution
from pycbc.types.optparse import DictWithDefaultReturn

def remove_options(parser, options):
    for option in options:
        for action in parser._actions:
            if vars(action)['option_strings'][0] == option:
                parser._handle_conflict_resolve(None,[(option,action)])
                break

def trigger_from_statmap(args):
    pass

def params_from_waveformstr(wstr):
    wparams = {}
    for param in wstr:
        key, value = param.split(':')
        try:
            rvalue = float(value)
        except ValueError:
            rvalue = value
        wparams[key] = rvalue
    return wparams

def network_snr(wparam, trig_time, stilde, psd, fixed):
    mchirp = wparam[0]
    q = wparam[1]
    spin = wparam[2]

    p = fixed.copy()
    p['mass1'] = pycbc.conversions.mass1_from_mchirp_q(mchirp, q)
    p['mass2'] = pycbc.conversions.mass2_from_mchirp_q(mchirp, q)
    p['spin1z'] = spin
    p['spin2z'] = spin
    out = pycbc.types.zeros(len(psd.values()[0]), dtype=numpy.complex64)
    hp = pycbc.waveform.get_waveform_filter(out,
                                            delta_f=stilde.values()[0].delta_f,
                                             **p)
    nsnr = 0
    for ifo in strain:
        snr = pycbc.filter.matched_filter(hp, stilde[ifo], psd=psd[ifo],
                                         low_frequency_cutoff=fixed['f_lower'])
        z = snr.time_slice(trig_time - 0.1, trig_time + 0.1)
        nsnr += abs(z).max() ** 2.0
    return -nsnr ** 0.5

parser = argparse.ArgumentParser()
parser.add_argument('--version', action='version',
    version=pycbc.version.git_verbose_msg)
parser.add_argument('--verbose', action='store_true')
parser.add_argument('--output-file')

# Options related to getting trigger information from workflow products
parser.add_argument('--input-file',
    help="HDF File which gives the trigger followup information for a set")
parser.add_argument('--start-index', type=int)
parser.add_argument('--end-index', type=int)

# Options to directly supply followup information
parser.add_argument('--template-parameters', nargs='+')
parser.add_argument('--trigger-time', type=float)
parser.add_argument('--instruments', nargs='+',
    help="Maximum set of instruments which may be used")

# Options related to data / signal processing options
parser.add_argument('--low-frequency-cutoff', type=float)
pycbc.strain.insert_strain_option_group_multi_ifo(parser)
remove_options(parser, ['--gps-start-time', '--gps-end-time'])

args = parser.parse_args()
pycbc.init_logging(args.verbose)

if args.input_file:
    f = h5py.File(args.input_file, 'r')
    start = 0 if args.start_index is None else args.start_index
    end = -1 if args.end_index is None else args.end_index

elif args.trigger_time:
    waveparams = params_from_waveformstr(args.template_parameters)
    toffset = {ifo:0 for ifo in args.instruments}
    triggers = ([args.trigger_time], [toffset], [waveparams])

# Determine what data we need to read and prepare
for trigger_time, time_offsets, waveparams in zip(*triggers):
    psdlen = 128
    psdseg = 8

    m1, m2 = waveparams['mass1'], waveparams['mass2']
    mchirp = pycbc.conversions.mchirp_from_mass1_mass2(m1, m2)
    waveparams['approximant'] = 'SPAtmplt' if mchirp < 3 else 'IMRPhenomD'
    templatelen = pycbc.waveform.get_waveform_filter_length_in_time(**waveparams)
    filterbuffer = templatelen + 5.0 + psdseg * 2
    filterbuffer = pycbc.pnutils.nearest_larger_binary_number(filterbuffer)
    logging.info('Template duration is %s seconds', templatelen)
    logging.info('We need %s seconds to filter this waveform', filterbuffer)

    args.gps_start_time = DictWithDefaultReturn()
    args.gps_end_time = DictWithDefaultReturn()
    psd_start = {}
    psd_end = {}
    filter_start = {}
    filter_end = {}
    for ifo in args.instruments:
        ctime = int(trigger_time)

        filter_end[ifo] = int(trigger_time + psdseg + 2)
        filter_start[ifo] = filter_end[ifo] - filterbuffer
        logging.info('%s: Filter buffer goes from %s-%s',
                     ifo, filter_start[ifo], filter_end[ifo])

        psd_start[ifo] = int(trigger_time - psdlen // 2)
        psd_end[ifo] = int(trigger_time + psdlen // 2)
        logging.info('%s: PSD data will be %s-%s', ifo, psd_start[ifo], psd_end[ifo])

        data_start = min(psd_start[ifo], filter_start[ifo]) - args.pad_data[ifo]
        data_end = max(psd_end[ifo], filter_end[ifo]) + args.pad_data[ifo]
        logging.info('%s: Will need data from %s-%s', ifo, data_start, data_end)

        args.gps_start_time[ifo] = data_start + args.pad_data[ifo] + time_offsets[ifo]
        args.gps_end_time[ifo] = data_end - args.pad_data[ifo] + time_offsets[ifo]
        logging.info('%s: actually reading %s-%s',
                     ifo, data_start + time_offsets[ifo],
                     data_end + time_offsets[ifo])

    logging.info('Calculating Strain around trigger')
    strain = pycbc.strain.from_cli_multi_ifos(args, args.instruments,
                                              dyn_range_fac=pycbc.DYN_RANGE_FAC)

    # Undo any time offsets for slides
    for ifo in strain:
        strain[ifo].start_time -= time_offsets[ifo]

    stilde = {ifo: strain[ifo].time_slice(
                            filter_start[ifo],
                            filter_end[ifo]).to_frequencyseries() for ifo in strain}

    logging.info('Calculating PSD around time')
    psd = {ifo: strain[ifo].time_slice(psd_start[ifo], psd_end[ifo]).filter_psd(
                           psdseg,
                           stilde[ifo].delta_f,
                           args.strain_high_pass[ifo]) for ifo in strain}

    logging.info('Optimizing Parameters')
    ################# Need better way to specific limits and ensure boundaries#
    minchirp = mchirp * (1 - mchirp / 100.0)
    maxchirp = mchirp * (1 + mchirp / 100.0)
    if minchirp < 1:
        minchirp = 1
    if maxchirp > 80:
        maxchirp = 80

    q = max(m1 / m2, m2 / m1)
    minq = q * 0.7
    maxq = q * 1.5
    if minq < 1:
        minq = 1.0
    if maxq > 100:
        maxq = 100
    logging.info('Using chirp mass range %s-%s', minchirp, maxchirp)
    logging.info('Using mass ratio range %s-%s', minq, maxq)

    bounds = [(minchirp, maxchirp),
              (minq, maxq),
              (-.98, 0.98), # Range of Spin
             ]
    result = differential_evolution(network_snr, bounds, popsize=20,
                                    args=(trigger_time, stilde,
                                          psd, waveparams),
                                    seed=0)
    print result
logging.info('Done')
