#!/bin/env python
"""Followup a candidate"""
import h5py, numpy, argparse, logging, time
import healpy
import scipy.special, scipy.integrate
import numpy.random
import pycbc.version, pycbc.strain, pycbc.waveform, pycbc.pnutils, pycbc.filter
import pycbc.conversions, pycbc.types, pycbc.dq, pycbc.scheme, pycbc.detector
from scipy.optimize import differential_evolution
from pycbc.types.optparse import DictWithDefaultReturn

def params_from_waveformstr(wstr):
    wparams = {}
    for param in wstr:
        key, value = param.split(':')
        try:
            rvalue = float(value)
        except ValueError:
            rvalue = value
        wparams[key] = rvalue
    return wparams

def network_snr(wparam, trig_time, stilde, psd, fixed):
    mchirp, q, spin = wparam
    p = fixed.copy()
    p['mass1'] = pycbc.conversions.mass1_from_mchirp_q(mchirp, q)
    p['mass2'] = pycbc.conversions.mass2_from_mchirp_q(mchirp, q)
    p['spin1z'] = p['spin2z'] = spin
    with ctx:
        out = pycbc.types.zeros(len(psd.values()[0]), dtype=numpy.complex64)
        hp = pycbc.waveform.get_waveform_filter(out,
                            delta_f=stilde.values()[0].delta_f, **p)
        nsnr = 0
        for ifo in strain:
            snr = pycbc.filter.matched_filter(
                        hp, stilde[ifo], psd=psd[ifo],
                        low_frequency_cutoff=p['f_lower'])
            z = snr.time_slice(trig_time - 0.1, trig_time + 0.1)
            nsnr += abs(z).max() ** 2.0
    return -nsnr ** 0.5

def coherent_likelihood(wparam, trig_time, stilde, psd, fixed):
    t0 = time.time()
    # Determines density of sky grid ##############################################
    numpy.random.seed(0)
    NSIDE = 15
    MSIZE = 50
    DSIZE = 100
    DMAX = 5000
    fiducial_time = 1000000000
    def pix2radec(index):
        theta, phi=healpy.pixelfunc.pix2ang(NSIDE, index)
        return numpy.pi*2. - phi, numpy.pi/2 - theta

    n = healpy.nside2npix(NSIDE)
    #logging.info('Using %s skypoints', n)
    ra, dec = pix2radec(numpy.arange(0, n))

    #inc = numpy.linspace(0, numpy.pi * 2, num=MSIZE)
    #pol = numpy.random.uniform(0, numpy.pi * 2, size=MSIZE)
    #dist = numpy.linspace(1, DMAX, num=DSIZE)
    # Let's assume this is zero for now (i.e. not measurable)
    pol = 0

    # Precalculate fp, fc and dt arguments
    fp, fc, dt = {}, {}, {}
    for ifo in args.instruments:
        d = pycbc.detector.Detector(ifo)

        # We can ignore time here as we'll marginalize over the entier sky anyway
        fp[ifo], fc[ifo] = d.antenna_pattern(ra, dec, pol, fiducial_time)
        dt[ifo] = d.time_delay_from_earth_center(ra, dec, fiducial_time)

    mchirp, q, spin = wparam
    p = fixed.copy()
    p['mass1'] = pycbc.conversions.mass1_from_mchirp_q(mchirp, q)
    p['mass2'] = pycbc.conversions.mass2_from_mchirp_q(mchirp, q)
    p['spin1z'] = p['spin2z'] = spin
    with ctx:
        out = pycbc.types.zeros(len(psd.values()[0]), dtype=numpy.complex64)
        hp = pycbc.waveform.get_waveform_filter(out,
                            delta_f=stilde.values()[0].delta_f,
                            distance=1.0/pycbc.DYN_RANGE_FAC, inclination=0, **p)

        snrs = {}
        norm = {}
        hh = {}
        maxtime = 0
        maxsnr = 0
        maxifo = ''
        nsnr = 0
        for ifo in stilde:
            snr, corr, norm[ifo] = pycbc.filter.matched_filter_core(
                        hp, stilde[ifo], psd=psd[ifo],
                        low_frequency_cutoff=p['f_lower'])
            snrs[ifo] = snr.time_slice(trig_time - 0.2, trig_time + 0.2).copy()
            s = abs(snrs[ifo] * norm[ifo])
            kmin = len(snrs[ifo]) // 4
            kmax = kmin * 3
            i = s[kmin:kmax].abs_arg_max()
            nsnr += s[kmin:kmax][i] ** 2.0
            if s[i] > maxsnr:
                maxtime = s[kmin:kmax].sample_times[i]
                maxsnr = s[kmin:kmax][i]
                maxifo = ifo

            hh[ifo] = -0.5 * (4.0 * stilde[ifo].delta_f / norm[ifo]) ** 2.0

    off = dt[maxifo].copy()
    for ifo in args.instruments:
        dt[ifo] -= off

    # This can be sped up a lot by reducing to unique indices
    sh = {}
    for ifo in args.instruments:
        idx = (dt[ifo] + (maxtime - snrs[ifo].start_time)) * snrs[ifo].sample_rate
        idx = idx.astype(numpy.int)
        sh[ifo] = snrs[ifo].take(idx) * 4.0 * stilde[ifo].delta_f
    skymult = 1

    def loglr(dist):
        inc = 0
        shloglr = hhloglr = 0
        ip = numpy.cos(inc)
        ic = 0.5 * (1.0 + ip * ip) * 1.0j

        for ifo in fp:
            htf = (fp[ifo] * ip + fc[ifo] * ic)
            shloglr += sh[ifo] * htf / dist
            hhloglr += hh[ifo] * abs(htf) ** 2.0 / dist ** 2.0

        vloglr = numpy.log(scipy.special.i0e(abs(shloglr)))
        vloglr += abs(shloglr) + hhloglr

        return numpy.log(numpy.exp(vloglr * skymult).sum())

    t1 = time.time()
    a, b = scipy.integrate.quadrature(loglr, 1, 5000, rtol=1e-3, vec_func=False)
    a /= 5000.0
    t2 = time.time()
    #print (t2 - t1) * 0.1, t2 - t0
    #exit()

    return (a * 2) ** 0.5

parser = argparse.ArgumentParser()
parser.add_argument('--version', action='version',
    version=pycbc.version.git_verbose_msg)
parser.add_argument('--verbose', action='store_true')
parser.add_argument('--output-file')

# Options related to getting trigger information from workflow products
parser.add_argument('--input-file',
    help="HDF File which gives the trigger followup information for a set")
parser.add_argument('--start-index', type=int)
parser.add_argument('--end-index', type=int)
parser.add_argument('--stride', type=int, default=1)

# Options to directly supply followup information
parser.add_argument('--template-parameters', nargs='+')
parser.add_argument('--trigger-time', type=float)
parser.add_argument('--instruments', nargs='+',
    help="Maximum set of instruments which may be used")

parser.add_argument('--adjust-psd-center', action='store_true',
    help="If using an hdf_store check the internal segments and "
         "match the time to the available data")

# Options related to data / signal processing options
parser.add_argument('--low-frequency-cutoff', type=float)
pycbc.strain.insert_strain_option_group_multi_ifo(parser, gps_times=False)
pycbc.scheme.insert_processing_option_group(parser)

args = parser.parse_args()
pycbc.init_logging(args.verbose)
ctx = pycbc.scheme.from_cli(args)

###############################################################################

ofile = h5py.File(args.output_file, 'w')
if args.input_file:
    f = h5py.File(args.input_file, 'r')
    start = 0 if args.start_index is None else args.start_index
    end = len(f['time']) if args.end_index is None else args.end_index
    stride = args.stride
    ofile.attrs['start_index'] = start
    ofile.attrs['end_index' ] = end
    ofile.attrs['stride'] = stride
    wparams = f['waveparams'][start:end:stride]
    triggers = (f['time'][start:end:stride], f['offsets'][start:end:stride],
                [dict(zip(wparams.dtype.names, x)) for x in wparams])

elif args.trigger_time:
    waveparams = params_from_waveformstr(args.template_parameters)
    toffset = {ifo:0 for ifo in args.instruments}
    triggers = ([args.trigger_time], [toffset], [waveparams])

if args.adjust_psd_center:
    segs = {}
    for ifo in args.instruments:
        f = h5py.File(args.hdf_store[ifo], 'r')
        segs[ifo] = (f[args.channel_name[ifo]]['segments/start'][:],
                     f[args.channel_name[ifo]]['segments/end'][:])


stats = []
for i, (trigger_time, time_offsets, waveparams) in enumerate(zip(*triggers)):
    logging.info('Starting work on trigger %s/%s: %s', i, len(triggers[0]), trigger_time)
    psdlen = 128
    psdseg = 8

    m1, m2 = waveparams['mass1'], waveparams['mass2']
    mchirp = pycbc.conversions.mchirp_from_mass1_mass2(m1, m2)
    waveparams['approximant'] = 'SPAtmplt' if mchirp < 3 else 'IMRPhenomD'
    templatelen = pycbc.waveform.get_waveform_filter_length_in_time(**waveparams)
    filterbuffer = templatelen + 4.0 + psdseg * 2
    filterbuffer = pycbc.pnutils.nearest_larger_binary_number(filterbuffer)
    logging.info('Template duration is %s seconds', templatelen)
    logging.info('We need %s seconds to filter this waveform', filterbuffer)

    args.gps_start_time = DictWithDefaultReturn()
    args.gps_end_time = DictWithDefaultReturn()
    psd_start, psd_end = {}, {}
    filter_start, filter_end = {}, {}
    data_start, data_end = {}, {}
    pad_start, pad_end = {}, {}

    # Allow an IFO to be excluded using a sentinel value
    ifos = [ifo for ifo in args.instruments if time_offsets[ifo] != numpy.inf]

    # Determine what data we need to read and prepare
    for ifo in ifos:
        # Choose filtering start / end times
        filter_end[ifo] = int(trigger_time + psdseg + 2)
        filter_start[ifo] = filter_end[ifo] - filterbuffer
        logging.info('%s: Filter buffer goes from %s-%s',
                     ifo, filter_start[ifo], filter_end[ifo])

        pad = 0 if args.pad_data[ifo] is None else args.pad_data[ifo]

        # Choose psd start / end times and recenter if needed #################
        psd_start[ifo] = int(trigger_time - psdlen // 2)
        if args.adjust_psd_center:
            idx = numpy.searchsorted(segs[ifo][0], trigger_time + time_offsets[ifo]) - 1
            start = segs[ifo][0][idx] - time_offsets[ifo]
            end = segs[ifo][1][idx] - time_offsets[ifo]
            logging.info('Must fit within %s-%s', start, end)
            if start > psd_start[ifo] - pad:
                psd_start[ifo] = start
            if end < psd_start[ifo] + pad + psdlen:
                psd_start[ifo] = end - pad - psdlen
        psd_end[ifo] = psd_start[ifo] + psdlen
        logging.info('%s: PSD data will be %s-%s', ifo, psd_start[ifo], psd_end[ifo])

        # Figure out when we can read data and if zero padding needs to be done
        data_start[ifo] = min(psd_start[ifo], filter_start[ifo]) - pad
        data_end[ifo] = max(psd_end[ifo], filter_end[ifo]) + pad
        logging.info('%s: Will need data from %s-%s', ifo, data_start[ifo], data_end[ifo])

        pad_start[ifo], pad_end[ifo] = 0, 0
        if args.adjust_psd_center:
            if data_start[ifo] < start + pad:
                pad_start[ifo] = start - data_start[ifo] + pad
                data_start[ifo] = start + pad
            if data_end[ifo] > end - pad:
                pad_end[ifo] = data_end[ifo] - end + pad
                data_end[ifo] = end - pad
            print pad_start[ifo], pad_end[ifo], segs[ifo][0][idx], segs[ifo][1][idx]
        args.gps_start_time[ifo] = data_start[ifo] + pad + time_offsets[ifo]
        args.gps_end_time[ifo] = data_end[ifo] - pad + time_offsets[ifo]
        logging.info('%s: actually reading %s-%s',
                     ifo, data_start[ifo] + time_offsets[ifo],
                     data_end[ifo] + time_offsets[ifo])

    logging.info('Calculating Strain around trigger')
    strain = pycbc.strain.from_cli_multi_ifos(args, ifos,
                                              dyn_range_fac=pycbc.DYN_RANGE_FAC)

    # Undo any time offsets for slides
    stilde = {}
    psd = {}
    for ifo in strain:
        strain[ifo].start_time = data_start[ifo] + pad

        # apply zero padding if needed.
        tpad = pad_start[ifo] + pad_end[ifo]
        if tpad > 0:
            logging.info('Applying zero padding')
            strain[ifo].resize(len(strain[ifo]) + strain[ifo].sample_rate * tpad)
            strain[ifo] = strain[ifo].cyclic_time_shift(pad_start[ifo])

        spart = strain[ifo].time_slice(filter_start[ifo], filter_end[ifo])
        stilde[ifo] = spart.to_frequencyseries()

        logging.info('Calculating PSD around time')
        spart = strain[ifo].time_slice(psd_start[ifo], psd_end[ifo])
        psd[ifo] = spart.filter_psd(psdseg, stilde[ifo].delta_f,
                                    args.low_frequency_cutoff)

    logging.info('Optimizing Parameters')
    minchirp = mchirp * (1 - mchirp / 200.0) # need better way to set limits
    maxchirp = mchirp * (1 + mchirp / 200.0)
    minchirp = 1 if minchirp < 1 else minchirp
    maxchirp = 80 if maxchirp > 80 else maxchirp

    q = max(m1 / m2, m2 / m1)
    minq, maxq = q * 0.7, q * 1.5
    minq = 1.0 if minq < 1 else minq
    maxq = 100 if maxq > 100 else maxq
    logging.info('Using chirp mass range %s-%s', minchirp, maxchirp)
    logging.info('Using mass ratio range %s-%s', minq, maxq)
    bounds = [(minchirp, maxchirp), (minq, maxq), (-.98, 0.98)]
    result = differential_evolution(coherent_likelihood, bounds,
                                    popsize=20,
                                    args=(trigger_time, stilde,
                                          psd, waveparams),
                                    disp=args.verbose, seed=0)
    logging.info(result)
    snr = result['fun'] * -1.0

    logging.info('Running Signal-Consistency Test')


    stats.append(snr)

ofile['stat'] = numpy.array(stats)
logging.info('Done')
