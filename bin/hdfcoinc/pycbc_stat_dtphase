#!/bin/env python
""" Create a file containing the phase and amplitude, 
correlations between two detectors by
doing a simple monte-carlo
"""

import argparse, h5py, numpy.random, pycbc.detector, logging, multiprocessing
from numpy.random import normal, uniform, power
parser = argparse.ArgumentParser()
parser.add_argument('--ifos', nargs=2)
parser.add_argument('--sample-size', type=int)
parser.add_argument('--snr-threshold', type=float)
parser.add_argument('--sample-rate', type=int, default=4096)
parser.add_argument('--max-combined-snr', type=float, default=25)
parser.add_argument('--coinc-threshold', type=float)
parser.add_argument('--output-file')
parser.add_argument('--cores', default=1, type=int)
parser.add_argument('--verbose', action='store_true')
args = parser.parse_args()
numpy.random.seed(seed=124)

d1 = pycbc.detector.Detector(str(args.ifos[0]))
d2 = pycbc.detector.Detector(str(args.ifos[1]))
maxdt = d1.light_travel_time_to_detector(d2)

max_csnr = args.max_combined_snr
max_ratio = numpy.log((max_csnr**2.0- args.snr_threshold**2.0) ** 0.5 / args.snr_threshold)
print max_ratio
tbins = numpy.linspace(- maxdt, maxdt, num=int(args.sample_rate * 2 * maxdt))
pbins = numpy.linspace(0, 2.0 * numpy.pi, num=100)
rbins = numpy.linspace(-max_ratio, max_ratio, num=40)
mbins = numpy.logspace(numpy.log(args.snr_threshold * 2 ** 0.5), numpy.log(max_csnr), num=30, base=numpy.e)

hist_bins = (tbins, pbins, rbins, mbins)
print tbins
print pbins
print rbins
print mbins


fsize = 20000 * 2000
dist = power(3, fsize) / args.snr_threshold

pycbc.init_logging(args.verbose)

def generate_hist(size):
    total = 0
    data = None
    chunksize = 20000 if 20000 < size else size
    while total < size:
        total += chunksize
        chunk_hist, _ = numpy.histogramdd(generate_samples(chunksize), bins=hist_bins)
        if data is None:
            data = chunk_hist
        else:
            data += chunk_hist
    return data

def generate_samples(size):
    logging.info('generating %s samples' % size)
    # Choose random sky location and polarizations
    ra = uniform(0, 2 * numpy.pi, size=size)
    dec = numpy.arccos(uniform(-1., 1., size=size)) - numpy.pi/2
    pol = uniform(0, 2 * numpy.pi, size=size)
    inc = uniform(0, 2 * numpy.pi, size=size)
    ip = numpy.cos(inc)
    ic = 0.5 * (1.0 + ip * ip)

    # Calculate the expected time offset, and fp,fc for both detectors
    fp1, fc1, fp2, fc2, td = [], [], [], [], []
    for r, d, p in zip(ra, dec, pol):
        r1, r2 = d1.antenna_pattern(r, d, p, 0)
        fp1.append(r1)
        fc1.append(r2)
        r1, r2 = d2.antenna_pattern(r, d, p, 0)
        fp2.append(r1)
        fc2.append(r2)
        
        t1 = d1.time_delay_from_earth_center(r, d, 0)
        t2 = d2.time_delay_from_earth_center(r, d, 0)
        td.append(t1 - t2)

    # Scale fp fc to a volumentric distribution of SNRs
    # add on gaussian errors in SNR
    
    phase_diff = (numpy.arctan2(fp1 * ip, fc1 * ic) - numpy.arctan2(fp2 * ip, fc2 * ic)) % (numpy.pi * 2)
     
    sp1 = fp1 * ip
    sp2 = fp2 * ip
    sc1 = fc1 * ic
    sc2 = fc2 * ic

    # Remove points below the SNR threshold
    s1 = sp1**2.0 + sc1**2.0
    s2 = sp2**2.0 + sc2**2.0
    
    ratio = numpy.resize(numpy.log((s1 / s2)) * 0.5, len(dist))
    
    s1 = numpy.resize(s1, len(dist)) / dist / dist
    s2 = numpy.resize(s2, len(dist)) / dist / dist
    
    t = s1 > args.snr_threshold ** 2.0
    t2 = s2 > args.snr_threshold ** 2.0
    t = numpy.logical_and(t, t2)

    s1 = s1[t]
    s2 = s2[t]
    
    mag = (s1 + s2)**0.5
    td = numpy.resize(td, len(dist))[t]
    ratio = ratio[t]
    phase_diff = numpy.resize(phase_diff, len(dist))[t]
    logging.info('keeping %s samples ' % len(ratio))
    
    print len(td), len(phase_diff), len(ratio), len(mag)
    return td, phase_diff, ratio, mag

fiddle = 3
core_size = int(args.sample_size / args.cores) / fiddle
chunk_data = [core_size] * args.cores * fiddle

if args.cores == 1:
    h = map(generate_hist, chunk_data)
else:
    pool = multiprocessing.Pool(args.cores)
    h = pool.map(generate_hist, chunk_data)

h = numpy.sum(h, axis=0)
f = h5py.File(args.output_file, 'w')

f['map'] = h
f['tbins'] = tbins
f['pbins'] = pbins
f['rbins'] = rbins
f['mbins'] = mbins
f.attrs['ifo0'] = args.ifos[0]
f.attrs['ifo1'] = args.ifos[1]
f.attrs['stat'] = "phasetd_newsnr"

